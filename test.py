#
# This script is an example of how to interface with an online Zotero library, and
# in particular how to use the resultant tagged data to narrow down the potential
# entries of interest on the basis of the tags assigned to each entry.
#
# The script downloads and caches a tagged data set from Zotero; if a previously
# cached data set exists in the local directory, the download from Zotero is skipped.
#
# The use of cached data prevents us having to hit the Zotero website every time the
# script is run; this could cause problems if the Zotero website is down, or if
# Zotero throttles the number of requests allowed over its REST API. In any case,
# sending out for an additional download from Zotero each time would slow things down!
#
# Requirements:
#
# PyZotero : https://github.com/urschrei/pyzotero (https://pyzotero.readthedocs.io/en/latest/)
#
# E.g.: pip3 install pyzotero
#

import os, json
from pyzotero import zotero

##########################################################################
# CHANGE THIS BEFORE ADDING TO ANY PUBLIC REPOSITORIES!                  #
#                                                                        #
# Temporary hardwiring - don't leave the api key in the code, obviously! #
# These should be environment variables or passed via command line.      #
##########################################################################

# Identify the Zotero library, and specify whether it's a user-specific
# library, or a group library
library_id = "2547147"
library_type = "group"

# This access key is generated from a Zotero account that has access to the
# specified library: https://www.zotero.org/support/dev/web_api/v3/basics
api_key = "YOUR_ZOTERO_ACCESS_KEY_HERE"

# Local output file for cached Zotero results (json format, portable)
cache_path = 'items.json'


#
# Simple utility class for Zotero results to allow mapping of tags into
# Zotero items. We assume items as per "entry" data generated by PyZotero.
#
# For our purposes, the important parts of PyZotero's "entry" data structure are:
#
#   entry['key'] = unique key to identify this entry in the Zotero library
#   entry['data']['tags'] = tagsm in the format [ {'tag': $tag1}, {'tag': $tag2}, ... ]
#
class ZoteroMap:

	def __init__(self, entries=None):
		#
		# This class uses two internal maps:
		#
		# - tag => [key, key, ...]
		# - key => PyZotero entry
		#
		self.tag_to_keys = {}
		self.key_to_entry = {}

		if entries != None: self.add_entries(entries)

	def add_entries(self, entries):
		for entry in entries:
			key, data = entry['key'], entry['data']
			tags = [ x['tag'] for x in data['tags'] ]

			self.key_to_entry[key] = entry

			for tag in tags:
				if tag not in self.tag_to_keys:
					self.tag_to_keys[tag] = [key]
				else:
					self.tag_to_keys[tag].append(key)

	# returns [[key,...],...] : list of keys for each tag in tags[]
	def tags_to_keysets(self, tags):
		t2k = self.tag_to_keys
		return [t2k[tag] for tag in tags if tag in t2k]

	# returns flattened version of [[key,...],...] from tags_to_keysets(), with
	# duplicates removed.
	def tags_to_keyset(self, tags):
		keysets = self.tags_to_keysets(tags)
		return { k: True for k in [k for ks in keysets for k in ks] }.keys()

	# Returns list of keys that have ANY of the specified tags
	def any_tag(self, tags):
		return self.tags_to_keyset(tags)
		
		keys, x = [k for ks in self.tags_to_keysets(tags) for k in ks], {}
		for key in keys: x[key] = True
		return list(x.keys())

	# Returns list of keys that have ALL of the specified tags
	def all_tags(self, tags):
		keys, x = [k for ks in self.tags_to_keysets(tags) for k in ks], {}
		for key in keys: x[key] = x[key]+1 if (key in x) else 1
		return [key for key in x if (x[key] == len(tags))]

	# ToDo: add progressive filtering by passing (optional) set of keys
	# into the above routines.

	# Add note regarding an NOT operation!

#
# Try to load previously cached data, or fetch from Zotero website if no
# cached data file is present.
# Saving data as "prettified" json produces a file ~30% larger in some cases,
# which currently means approx. 630 kB -> 940 kB, so we likely shouldn't use
# prettification unless we know the cached file is going to be read by humans!
#

if os.path.isfile(cache_path):

	print(f'Reading cache data from "{cache_path}"')
	s = open(cache_path).read()
	items = json.loads(s)

else:

	print(f'Fetching library data from Zotero')
	zot = zotero.Zotero(library_id, library_type, api_key)
	items = zot.everything( zot.top() )
	s = json.dumps(items)
	
	print(f'Writing cache data to "{cache_path}"')
	with open(cache_path,'w') as f:
		f.write(s)

	print(f'Writing prettified cache data')
	with open('items.pretty.json','w') as f:
		for item in items:
			print(json.dumps(item, sort_keys=True,indent=4), file=f)

#
# Generate a Zotero object from the data we retrieved
# ToDo - note regarding which option we take and why.

zm = ZoteroMap(items)
for tag in zm.tag_to_keys:
	print(tag, zm.tag_to_keys[tag])

tags = list(zm.tag_to_keys.keys())
print(tags)

ksets = zm.tags_to_keysets(tags)
for (i,kset) in enumerate(ksets):
	print(i, tags[i])
	for k in kset:
		print(f'  {k}')
	print()

print()
print()



print('HERE:')
ksets = zm.tags_to_keysets(tags)
blah = []
for kset in ksets:
	for k in kset:
		if k in blah: continue
		blah.append(k)

blah2 = list(zm.tags_to_keyset(tags))

print(len(blah), blah)
print(len(blah2), blah2)
for i,k in enumerate(blah):
	if k != blah2[i]:
		print(f'PROBLEM: {i} : {k} != {blah2[i]}')
		sys.exit(-1)





tags2 = tags[:5] + ['Statistics'] # tags[:5]
print(tags2)

print(f'Any tag: {tags2}')
keys = zm.any_tag(tags2)
for key in keys:
	tags = zm.key_to_entry[key]['data']['tags']
	print(f'  {key} : {[t["tag"] for t in tags]}')

print()
print()

print(f'All tags: {tags2}')
keys = zm.all_tags(tags2)
for key in keys:
	entry = zm.key_to_entry[key]
	print(f'  {key} : {entry["data"]["tags"]}')
